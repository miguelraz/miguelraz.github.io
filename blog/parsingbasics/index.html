<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <script src="libs/clipboard.min.js"></script> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/basic.css"> <link rel=icon  href="/assets/favicon.png"> <title>Parsing Basics with Parsers.jl</title> <header> <div class=blog-name ><a href="">PathToPerformance</a></div> <nav> <ul> <li><a href="/">Home</a> <li><a href="/diary/">Work Diary</a> <li><a href="/blog/">Blog</a> <li><a href="/pubs/">Publications/Talks/Videos</a> <li><a href="/teaching/">Teaching/Translations</a> <li><a href="/tags/">Tags</a> <li><a href="/about/">About</a> <script src="/libs/clipboard.js"></script> </ul> <img src="/assets/hamburger.svg" id=menu-icon > </nav> </header> <div class=franklin-content ><h3 id=parsing_basics_-_how_to_use_parsersjl_to_parse_formats_for_high_performance ><a href="#parsing_basics_-_how_to_use_parsersjl_to_parse_formats_for_high_performance">Parsing basics - how to use Parsers.jl to parse formats for high performance</a></h3> <div class=franklin-toc ><ol><li><a href="#parsing_basics_-_how_to_use_parsersjl_to_parse_formats_for_high_performance">Parsing basics - how to use Parsers.jl to parse formats for high performance</a><li><a href="#what_is_parsing">What is parsing?</a><li><a href="#why_should_i_care">Why should I care?</a><li><a href="#how_fast_can_you_go">How fast can you go?</a><li><a href="#oooh_-_parsing_tricks">Oooh - parsing tricks&#33;</a><li><a href="#the_format_to_be_parsed">The format to be parsed</a><ol><li><ol><li><a href="#todo">TODO ??? </a><li><a href="#success">Success&#33; ðŸ”¥</a></ol></ol></ol></div> <p>~ 20 minutes.</p> <ul> <li><p>This post talks about parsing, aka how to read file. It is focused on formats of interest for scientific / data processing, but is meant more as an introduction than a complete overview.</p> <li><p>We will use Julia, Parsing.jl, and will be trying to parse the <a href=X >DOT</a> and <a href=X >EdgeList</a> formats.</p> <li><p>This post draws from my experience rewriting a graph formats parsing library, <a href=X >LightGraphsIO</a>, and is intended to be documentation / a tutorial for others / Parsers.jl who may venture into similar waters.</p> <li><p>Special shout out to the LightGraphs.jl contributors and to Jacob Quinn, who kindly answered my questions about his Parsers.jl library.</p> </ul> <h3 id=what_is_parsing ><a href="#what_is_parsing">What is parsing?</a></h3> <p>For us, parsing involves reading data from a file. They usually have a specification for how the file should be structured.</p> <h3 id=why_should_i_care ><a href="#why_should_i_care">Why should I care?</a></h3> <p>Some programming tasks will require you to read data and not be stuck all day waiting for the data to load &#40;as it was our case.&#41;. If it&#39;s a bottleneck for your work, consider diving in&#33; Otherwise, its probably best to just call a library to handle it.</p> <h3 id=how_fast_can_you_go ><a href="#how_fast_can_you_go">How fast can you go?</a></h3> <p>Quite fast, depending on your approach. The &quot;simplest&quot; &#40;but by no means trivial&#41; kind of parsing is byte-at-a-time. You look at one character, and depending on what you&#39;ve seen, decide what to do, and push it into a relevant data structure and keep going. That approach hits a roof of about &#40; &#41; according to these calculations by Daniel Lemire, an absolute pro at this sort of stuff. His team&#39;s approach let&#39;s them parse some formats at a whopping &#40; &#41; by using SIMD vectorization &#40;aka, oodles of parallelism, very close to assembly level&#41;. We may cover that approach in a later post, but for now we&#39;ll be happy with Parsers.jl that does some clever byte-at-a-time optimizations to still get respectable for our needs. This post however will cover some of Julia&#39;s <strong>multithreading</strong> capabilities. This will help us leverage the fact that modern computers aren&#39;t getting much faster, but there are more processors we can use.</p> <h3 id=oooh_-_parsing_tricks ><a href="#oooh_-_parsing_tricks">Oooh - parsing tricks&#33;</a></h3> <p>We&#39;ll do some Memory mapping and using bitmasks. Don&#39;t worry, this all comes &quot;out of the box&quot; in Julia.</p> <p>Briefly:</p> <ul> <li><p><em>memory mapping</em> : Convert a file to a vector of bytes. This will ideally greatly improved the processing speed of your file because we are using byte operations instead of string operations.</p> </ul> <p>You can do this in Julia with a simple</p> <pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-keyword >using</span> Mmap
</span><span class=hljs-meta >julia&gt;</span><span class=julia > mm = Mmap.mmap(<span class=hljs-string >&quot;file.txt&quot;</span>)</span></code></pre> <ul> <li><p><em>bit masks</em> : Instead of using several variables for many binary conditions, we stick them all in a single memory chunk and use bit operations to get out the useful information.</p> </ul> <p>Which usually looks like</p> <pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-number >0b0001</span> &amp; <span class=hljs-number >1</span> <span class=hljs-comment ># notice the 0b01 is a binary literal</span>
</span>1</code></pre> <p>If you&#39;re smart about it, you can use those resulting 1s for control branchless control flow, which also helps performance.</p> <h3 id=the_format_to_be_parsed ><a href="#the_format_to_be_parsed">The format to be parsed</a></h3> <p>We&#39;ll get start with a <code>EdgeList</code> &#40;called <code>&quot;simple.edgelist&quot;</code>&#41; file, they look like this:</p> <pre><code class="julia hljs"><span class=hljs-number >6</span> <span class=hljs-number >7</span>
<span class=hljs-number >1</span> <span class=hljs-number >2</span>
<span class=hljs-number >2</span> <span class=hljs-number >3</span>
<span class=hljs-number >6</span> <span class=hljs-number >3</span>
<span class=hljs-number >5</span> <span class=hljs-number >6</span>
<span class=hljs-number >2</span> <span class=hljs-number >5</span>
<span class=hljs-number >2</span> <span class=hljs-number >4</span>
<span class=hljs-number >4</span> <span class=hljs-number >1</span></code></pre> <p>Where the first two digits correspond to <code>n</code> edges and <code>m</code> vertices, and the file has <code>m</code> lines.</p> <pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-keyword >using</span> Mmap, Parsers
</span>
<span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-keyword >const</span> opts = Parsers.Options(delim = <span class=hljs-string >&#x27; &#x27;</span>, wh1 = <span class=hljs-number >0x00</span>)
</span>
<span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-keyword >function</span> read_two(file)
            <span class=hljs-comment ># 1. MMap the file </span>
            io = Mmap.mmap(file)
</span>
            # 2. call xparse
            pos = 1
            x, code, vpos, vlen, tlen = Parsers.xparse(Int, io, pos, sizeof(io), opts)

            # 3. Advance the cursor by the &#x27;tab length&#x27;
            pos += tlen
            y, code, vpos, vlen, tlen = Parsers.xparse(Int, io, pos, sizeof(io), opts)
            x, y
            
            # 4. Oops! skipped error handling!
       end</code></pre> <p>This is one of the &quot;easier&quot; cases that Parsers.jl can handle, so let&#39;s break down <code>read_two&#40;&quot;simple.edgelist&quot;&#41;</code>:</p> <pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > read_two(<span class=hljs-string >&quot;simple.edgelist&quot;</span>, EdgeListFormat) == (<span class=hljs-number >6</span>, <span class=hljs-number >7</span>)
</span>true</code></pre> <h5 id=todo ><a href="#todo">TODO ??? </a></h5> <ol> <li><p>Setup the appropriate <a href="https://github.com/JuliaData/Parsers.jl/blob/589b9d0f80998ec284874b300da0932557d33513/src/Parsers.jl#L8">Parsers.Options</a> struct, which will dispatch on the parsing behavior. We&#39;re basically wrapping up all the presets for this file that are important: our delimiter is the <code>&#39; &#39;</code> whitespace character and the <code>wh1</code> &#61;&#61; ???</p> <li><p>We use the <code>Mmap</code> trick to convert our file into a stream of bytes to get a performance boost.</p> <li><p>The argumnents to <code>xparse</code> tell you where and what to start parsing <code>Parsers.xparse&#40;Int, io, pos, sizeof&#40;io&#41;, opts&#41;</code> :</p> <ul> <li><p><code>Int</code> - Type of the value we are parsing</p> <li><p><code>io</code> - handler to the io stream</p> <li><p><code>pos</code> - to know where to start parsing</p> <li><p><code>sizeof&#40;io&#41;</code> - to know if you have reached the end of <code>io</code></p> <li><p><code>opts</code> - to handle our parsing options.</p> </ul> <li><p>We get a bunch of variables back from <code>xparse</code> - the docstrings <a href="https://github.com/JuliaData/Parsers.jl/blob/589b9d0f80998ec284874b300da0932557d33513/src/Parsers.jl#L148">here are quite overwhelming</a> but it&#39;s not too bad once we stare at it for a while:</p> <ul> <li><p><code>x</code> is the value we parsed, <code>6</code> in this case.</p> <li><p><code>code</code> is our bitmask to get back what actually happened in the parsing â€“ particularly useful for error handling. This is will be done through <a href="https://github.com/JuliaData/Parsers.jl/blob/ab5ef1bbdc81fe8ee979a5b287ea065d991ba0ce/src/utils.jl#L44">bit operations</a></p> <li><p><code>vpos, vlen, tlen</code> where exactly our &quot;parsing cursor&quot; is at. This book keeping to know where to start parsing next.</p> </ul> <li><p>TODO Error handling</p> </ol> <p>So that&#39;s our basic building block for how to get started with Parsers.jl.</p> <p>Now let&#39;s try and write the rest of the code to read a whole file that contains a single graph:</p> <pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-keyword >function</span> load_graph(file_name, ::<span class=hljs-built_in >Type</span>{EdgeListFormat}) <span class=hljs-comment ># The funky second argument is so that we filter for EdgeListFormat behavior, not important here.</span>
</span>    # yay code
end

<span class=hljs-meta >julia&gt;</span><span class=julia > g = load_graph(<span class=hljs-string >&quot;simple.edgelist&quot;</span>, EdgeListFormat)
</span>{6, 7} undirected Int64 simple graph</code></pre> <h5 id=success ><a href="#success">Success&#33; ðŸ”¥</a></h5> <p>Now, let&#39;s make it multithreaded with a test file of 100k rows, to see that we have something worthwhile.</p> <p>We write our file like this:</p> <pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > open(<span class=hljs-string >&quot;large.txt&quot;</span>, <span class=hljs-string >&quot;w+&quot;</span>) <span class=hljs-keyword >do</span> f
</span>	for i in 100_000
		println(rand(1:100_000), &#x27; &#x27;, rand(1:100_00))
	end
	end</code></pre> <div class=page-foot > <div class=copyright > &copy; Miguel Raz GuzmÃ¡n Macedo. Last modified: November 24, 2020. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> <script> (function(){ // Get the elements. // - the 'pre' element. // - the 'div' with the 'paste-content' id. var pre = document.getElementsByTagName('pre'); // Add a copy button in the 'pre' element. // which only has the className of 'language-'. for (var i = 0; i < pre.length; i++) { var isLanguage = pre[i].children[0].className.indexOf('language-'); if ( isLanguage === 0 ) { var button = document.createElement('button'); button.className = 'copy-button'; button.textContent = 'Copy'; pre[i].appendChild(button); } }; // Run Clipboard var copyCode = new Clipboard('.copy-button', { target: function(trigger) { return trigger.previousElementSibling; } }); // On success: // - Change the "Copy" text to "Copied". // - Swap it to "Copy" in 2s. // - Lead user to the "contenteditable" area with Velocity scroll. copyCode.on('success', function(event) { event.clearSelection(); event.trigger.textContent = 'Copied'; window.setTimeout(function() { event.trigger.textContent = 'Copy'; }, 2000); }); // On error (Safari): // - Change the "Press Ctrl+C to copy" // - Swap it to "Copy" in 2s. copyCode.on('error', function(event) { event.trigger.textContent = 'Press "Ctrl + C" to copy'; window.setTimeout(function() { event.trigger.textContent = 'Copy'; }, 5000); }); })(); </script>