<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <!--<link rel=stylesheet  href="/libs/highlight/github.min.css"> --> <link rel=stylesheet  href="/libs/highlight/styles/atom-one-dark.css"> <script src="libs/clipboard.min.js"></script> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/basic.css"> <link rel=icon  href="/assets/favicon.ico" type="image/x-icon"> <title>From Julia to Rust</title> <header> <div class=blog-name ><a href="">PathToPerformance</a></div> <nav> <ul> <li><a href="/">Welcome! üëãüèæ</a> <li><a href="/diary/">Diaryüìí</a> <li><a href="/blog/">Blogüí≠</a> <li><a href="/pubs/">Publications üìì /Talksüó£Ô∏è /Videosüé• </a> <li><a href="/teaching/">Teachingüéì/Translationsüó∫Ô∏è</a> <li><a href="/about/">CVüíÉ</a> <script src="/libs/clipboard.js"></script> </ul> <img src="/assets/hamburger.svg" id=menu-icon > </nav> </header> <div class=franklin-content ><h3 id=handy_learning_materials ><a href="#handy_learning_materials" class=header-anchor >Handy learning materials:</a></h3> <ul> <li><p>Rust book</p> <li><p>VScode and Rustanalyzer to just get started</p> <li><p>Tour of Rust</p> <li><p>cheat.rs</p> <li><p>Rust by example</p> <li><p>Rust docs</p> <ul> <li><p>Exercism</p> <li><p>Advent of Code by Amos</p> <li><p>Ryan Eberhardt Stanford <a href="https://reberhardt.com/blog/2020/10/05/designing-a-new-class-at-stanford-safety-in-systems-programming.html#lectures">course</a> </p> <li><p>Jeff Zarnett programming for performance course <a href="https://github.com/jzarnett/ece459">repo</a>, </p> </ul> </ul> <p>with a <a href="https://www.youtube.com/watch?v&#61;BE64OK7l20k&amp;list&#61;PLFCH6yhq9yAHnjKmB9RLA2Qdk3XhphqrN">full youtube playlist</a>,&#91;youtube links&#93;&#40;https://www.youtube.com/watch?v&#61;-MDHdqZvxxs&amp;list&#61;PLFCH6yhq9yAHnjKmB9RLA2Qdk3XhphqrN&amp;inde</p> <ul> <li><p>Rustlings</p> <li><p><a href="https://rust-unofficial.github.io/too-many-lists/">Too many linked lists</a></p> <li><p>Jon Gjengset streams: </p> <li><p><a href="https://www.youtube.com/watch?v&#61;h4RkCyJyXmM&amp;t&#61;2455s">sorting algos stream</a></p> <li><p><a href="https://www.youtube.com/watch?v&#61;rMGWeSjctlY">multicore and atomics</a></p> </ul> <h3 id=what_does_generic_rustian_code_look_like ><a href="#what_does_generic_rustian_code_look_like" class=header-anchor >What does generic Rustian code look like?</a></h3> <p>We love composability and multiple dispatch - what does that look like in Rust?</p> <ul> <li><p>In Julia land, how do I get generic code? <code>zero&#40;...&#41;</code>, <code>eltype&#40;...&#41;</code>, <code>where T&lt;:Foo</code></p> <li><p>In Rust Land, how do I get generic code? <code>impl&lt;T&gt;</code>,</p> <li><p>There&#39;s tons of boilerplate -_-</p> <li><p>There&#39;s a lot more syntax up front</p> <li><p>There&#39;s a lot more surface area to cover in learning the language</p> </ul> <h3 id=rustian_projects_of_interest ><a href="#rustian_projects_of_interest" class=header-anchor >Rustian projects of interest </a></h3> <ul> <li><p><a href="https://github.com/rayon-rs/rayon">rayon</a> is the original reason I got interested in Rust. Check their <a href="https://github.com/rayon-rs/rayon#parallel-iterators-and-more">hello world</a> - the promise is that if you are using iterators, you can swap &#40;in many cases&#41; <code>iter&#40;&#41;</code> for <code>par_iter&#40;&#41;</code> and at compile time you can know if your code will run in parallel. That&#39;s just about the friendliest user interface to parallelism besides <code>Threads.@threads</code>, and with some additional guarantees - a small update loop is easy to keep the invariants in your head, but it really pays when the Rust compiler catches a concurrency bug that spanned multiple files, modules and data structures. Cool tech note: Rayon uses the <a href="https://youtu.be/gof_OEv71Aw?t&#61;1184">same idea for work stealing thread scheduler</a> that Julia&#39;s parallel task run time system uses &#40;inspired by Cilk, get it? &#39;Cuz Rayon is a fake silk? Ha...&#41;. </p> <li><p><a href="">tokio</a> deserves a mention as well for its capabilities for asynchronous programming, but I am not familiar enough with it to comment on it. Rust people are excited about it though&#33; </p> </ul> <p>NB: Since Rust was adamant about shipping a minimal run time &#40;which means an automatic RC garbage collector and no threading run time&#41; they developed this library as external to stdlib. There&#39;s several social and technical constraints for why Tokio is not always included, like embedded systems and people who want to work on no stdlib environments. In Julia the devs just said &quot;let&#39;s implement the best one we have so that people don&#39;t implement their own and fragment the ecosystem&quot; and that&#39;s why we have the task run time we do. This means it is non-trivial to compose <code>rayon</code> and <code>tokio</code> codes.</p> <ul> <li><p><a href="https://egraphs-good.github.io/">egg</a></p> <li><p>cargo release <a href="https://deterministic.space/high-performance-rust.html">and other tricks</a></p> </ul> <p>x&#61;28&#41;</p> <ul> <li><p><a href="https://github.com/mmtk/mmtk-core">MMtk and GCs</a></p> <li><p>command line stuff rocks <a href="https://zaiste.net/posts/shell-commands-rust/">Rust CLI</a></p> <ul> <li><p>rg</p> <li><p>bat</p> <li><p>dust</p> <li><p>typeracer</p> <li><p>taskwarrior</p> <li><p>wool</p> <li><p>zoxide</p> </ul> <li><p><a href="https://github.com/plasma-umass/coz">coz</a></p> <li><p><a href="https://sled.rs/perf#e-prime-and-precise-language">sled&#39;s</a> approach to benchmarking</p> <li><p><a href="https://www.lpalmieri.com/posts/2019-02-23-scientific-computing-a-rust-adventure-part-0-vectors/">Scientific Computing</a> a Rust adventure and Rust ML to production</p> <li><p><a href="https://www.lpalmieri.com/posts/2019-12-01-taking-ml-to-production-with-rust-a-25x-speedup/">Taking ML to production with Rust</a></p> <li><p><a href="https://github.com/ejmahler/RustFFT">Rust FFT</a></p> <li><p><a href="https://github.com/rusty-fast-solvers/rusty-green-kernel">Green function evaluation kernels</a></p> <li><p><a href="https://docs.rs/polars/0.12.1/polars/">Polars</a></p> <li><p><a href="https://github.com/tokio-rs/loom">Loom</a></p> <li><p><a href="https://github.com/tokio-rs/loom">Stateright</a></p> <li><p><a href="https://github.com/xldenis/creusot">Creusot</a></p> <li><p><a href="https://altsysrq.github.io/proptest-book/proptest/getting-started.html">proptest</a></p> </ul> <h3 id=papercuts_and_sharp_edges ><a href="#papercuts_and_sharp_edges" class=header-anchor >Papercuts and sharp edges</a></h3> <ul> <li><p>Knowing the Rustian motivations:</p> <li><p>Stanford course, Carol Golding&#39;s talk, C&#43;&#43; dangling pointer example.</p> <li><p>Rust people keep saying they have no Garbage Collector, when they have an automatic Referenc Counting Garbage Collector. It&#39;s all fun and games until they have to implement those linked lists...</p> <li><p>Install <code>cargo-add</code>, use it to manage crate dependencies. That and some other tricks are great from doing the <code>AdventOfCode2020</code> from the article above.</p> <li><p>For numerics, install <code>ndarray</code> and <code>num_traits</code>. Linear Algebra and numerics where not a primary focus of Rust when starting out as they were with Julia.</p> <li><p>Benchmarking with <code>@btime</code> is painless, <code>criterion</code> is your best Rustian bet.</p> <li><p>Setup your <code>rust-analyzer</code> and <code>error lens</code> plugins on VSCode or IDE asap, you&#39;ll thank me later. Rust-land expects you to be in constant dialogue with the compiler, and making that iteration cycle as ergonomic as possible will yield dividends in the long run. What we don&#39;t get from accessing help docs in the REPL, Rust people keep a terminal tab handy where they run <code>cargo watch -c</code> and get continuous feedback from the compiler.</p> <li><p>You CAN&#39;T index into a String in Rust with ints&#33; <a href="https://doc.rust-lang.org/std/primitive.str.html#method.chars">Docs are here</a> use slices like <code>&amp;str&#91;1..&#93; &#61;&#61; str&#91;2:end&#93;</code>, to mix up Julia and Rust syntax.</p> <li><p>Reading from <code>stdin</code> is a pain as a newcomer. I wanted to try out some competitive coding exercises and reading from <code>stdin</code> was waaaay too rough for me at first. Eventually I cobbled this template up <a href="https://gist.github.com/miguelraz/d0341e9fee8c728baa99fd6fe86c1be1">link here</a> so that you don&#39;t struggle if you want to try a couple of CodeForces problems.</p> <li><p>Not having a generic <code>rand</code> is just painful. So painful. This is my easiest workaround so far for generating a vector of <code>n</code> random entries:</p> </ul> <pre><code class="rust hljs"><span class=hljs-keyword >use</span> rand::distributions::Standard;
    <span class=hljs-keyword >use</span> rand::prelude::*;
    <span class="hljs-title function_ invoke__">thread_rng</span>().<span class="hljs-title function_ invoke__">sample_iter</span>(&amp;Standard).<span class="hljs-title function_ invoke__">take</span>(n).<span class="hljs-title function_ invoke__">collect</span>()</code></pre> <p>&#40;Oh, and <code>rand</code> isn&#39;t part of the stdlib so that&#39;s another papercut&#41;.</p> <ul> <li><p>There is no <code>@code_native</code> and friends in Rust - your best bet is to use the Rust Playground and click on the <code>...</code> to have it emit the total assembly. This only works for the top 100 most popular crates though. You can <code>cargo run --release -- --emit&#61;llvm-ir/asm</code> and then fish the results out of <code>target/</code>, but that&#39;s unwieldy - why does no one have a CLI for this yet?</p> <li><p>Another multiple dispatch gripe: having to implement <code>Display</code> traits for new structs feels like pulling teeth, and this initial type signature seems inscrutable as a begineer:</p> </ul> <pre><code class="rust hljs"><span class=hljs-keyword >use</span> std::fmt;

<span class=hljs-keyword >struct</span> <span class="hljs-title class_">Point</span> {
    x: <span class=hljs-type >i32</span>,
    y: <span class=hljs-type >i32</span>,
}

<span class=hljs-keyword >impl</span> <span class="hljs-title class_">fmt</span>::Display <span class=hljs-keyword >for</span> <span class="hljs-title class_">Point</span> {
    <span class=hljs-keyword >fn</span> <span class="hljs-title function_">fmt</span>(&amp;<span class=hljs-keyword >self</span>, f: &amp;<span class=hljs-keyword >mut</span> fmt::Formatter&lt;<span class=hljs-symbol >&#x27;_</span>&gt;) <span class=hljs-punctuation >-&gt;</span> fmt::<span class=hljs-type >Result</span> {
        <span class=hljs-built_in >write!</span>(f, <span class=hljs-string >&quot;({}, {})&quot;</span>, <span class=hljs-keyword >self</span>.x, <span class=hljs-keyword >self</span>.y)
    }
}</code></pre> <ul> <li><p>Rust does NOT look like math and that hurts my little physicist heart. <a href="https://rust-lang.github.io/wg-async-foundations/vision/status_quo/niklaus_simulates_hydrodynamics.html">Look at this story of a hydrodynamics simulator code</a> vs anything in the DiffEq verse that is user facing or from ApproxFun.jl - worlds apart&#33; Even the linear algebra from <code>ndarray</code> is painful to understand unless you are quite comfortable in Rust, and all the <code>i as usize</code> conversions are a huge eye sore.</p> </ul> <h3 id=appreciation_of_rust_things ><a href="#appreciation_of_rust_things" class=header-anchor >Appreciation of Rust things</a></h3> <ol> <li><p>Rust people take uwu-ification very, VERY seriously. <a href="https://github.com/Daniel-Liu-c0deb0t/uwu">The uwu</a> project uses SIMD to uwu-ify strings for <a href="https://twitter.com/twent_weznowor">great artistic value</a></p> <li><p>Governance: The Rust foundation and strong community conduct codes. Given the blow ups that have happened with several open source communities recently from short-sighted governance or hate reactionaries tanking projects, this is a welcome sight that will probably pay off for many decades to come.</p> <li><p>Compiler error messages are second to none.</p> <li><p><a href="https://rustbeginners.github.io/awesome-rust-mentors/">Awesome mentors</a>. This is a project that is carried out by <code>Jane Lusby</code> and many others, I&#39;ve gotten world-class mentorship from very friendly Rust folks.</p> <li><p>They also poke the LLVM crowd to improve the compilation times, which is great.</p> </ol> <h3 id=things_i_wish_id_known_earlier ><a href="#things_i_wish_id_known_earlier" class=header-anchor >Things I wish I&#39;d known earlier</a></h3> <ol> <li><p>If you can, avoid the examples with Strings and &amp;str. Yes, they&#39;re a great motivation for systems people for all the gnarly use-after free and double-free and memory-leak examples - stick with numerical algorithms first, to get the gist of ownership, try and do some exercisms with iterators and Strings will be much easier to get after that. I don&#39;t think it&#39;s worth worrying about at first unless your target is systems.</p> <li><p>The preferred way of &quot;whipping up an example in the REPL&quot; is to <code>cargo new foo</code>, mucking about and then <code>cargo run --release</code> or using the Rust Playground.</p> <li><p>If you&#39;re using a very expansive test suite, <code>cargo test --test-threads 8</code> and <code>cargo test --quiet</code> are helpful flags.</p> <li><p>For loops are not idiomatic in Rust - writing Fortran-ey code instead of iterators will lead to pain and slower loops. Spending time reading the examples in <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">the iterator docs</a> and the community solutions in the exercisms will help a lot.</p> <li><p>Just clone everything when you are starting out to get around most borrow checker shenanigans - worry about allocations later, Rust is fast enough that this is not likely your bottleneck at first.</p> <li><p>The following function</p> </ol> <pre><code class="rust hljs"><span class=hljs-keyword >fn</span> <span class="hljs-title function_">dot</span>(v: &amp;[<span class=hljs-type >i32</span>], w: &amp;[<span class=hljs-type >i32</span>]) <span class=hljs-punctuation >-&gt;</span> <span class=hljs-type >i32</span> {...}</code></pre>
<p>the types of <code>v</code> and <code>w</code> are a <code>slice</code> of <code>Int32</code>s, which are different from <code>Vec&lt;32&gt;</code>. Read the Scientific Computing link above to see a nice table of the differences.</p>
<ol start=6 >
<li><p>Including docs and tests in the same file as your implementation is idiomatic - even the IDEs support clicking on the <code>#&#91;test&#93;</code> line and having that run. Julia has a nice workflow for test driven development out-of-the-box - Rust gives you some of those guarantees by... conversing with the compiler.</p>

<li><p>Polymorphism via macros: <code>#&#91;derive&#40;Debug, Hash, Eq&#41;&#93;</code> </p>

<li><p>Rust has something similar to the concept of <code>type piracy</code>: they&#39;re called the <code>orphan rules</code>, as explained by <a href="https://blog.mgattozzi.dev/orphan-rules/">this Michael Gattozzi</a> post:</p>

</ol>
<blockquote>
<p>Recently at work I managed to hit the Orphan Rules implementing some things for an internal crate. Orphan Rules you say? These are ancient rules passed down from the before times &#40;pre 1.0&#41; that have to do with trait coherence. Mainly, if you and I both implement a trait from another crate on the same type in another crate and we compile the code, which implementation do we use?</p>
</blockquote>
<ol start=9 >
<li><p>Rust is not as centralized with online communication as Julia is around Slack/Zulip/Discourse. Their version of <code>#appreciation</code> channels is to go on twitter and tell <code>@ekuber</code> what a joy the compilers errors are. There&#39;s tons of people on their Discord, and everywhere.</p>

</ol>
<h3 id=what_rust_can_bring_to_julia ><a href="#what_rust_can_bring_to_julia" class=header-anchor >What Rust can bring to Julia</a></h3>
<ol>
<li><p>A model of governance.</p>

<li><p>Less vulnerable software in the world is a good thing.</p>

</ol>
<ul>
<li><p><a href="https://www.usenix.org/conference/enigma2021/presentation/gaynor">Alex Gaynor talk</a>:</p>

<li><p><a href="https://www.helpnetsecurity.com/2021/01/27/cve-2021-3156/">sudo vulnerabilities</a>: Very bad ? Maybe?</p>

</ul>
<ol start=3 >
<li><p><a href="https://www.youtube.com/watch?v&#61;rAF8mLI0naQ&amp;t&#61;947s">Error handling</a>: Multiple dispatch may prove very advantageous </p>

<li><p>Awesome Julia mentors, I think we need this.</p>

</ol>
<h3 id=what_julia_can_bring_to_rust ><a href="#what_julia_can_bring_to_rust" class=header-anchor >What Julia can bring to Rust</a></h3>
<ol>
<li>
</ol>
<h3 id=optimization_walkthroughs ><a href="#optimization_walkthroughs" class=header-anchor >Optimization walkthroughs</a></h3>
<ol>
<li><p>COST paper</p>

<li><p><a href="https://parallel-rust-cpp.github.io/">Comparing parallel Rust and C&#43;&#43;</a></p>

<li><p><a href="https://deterministic.space/high-performance-rust.html">Cheap tricks</a></p>

<li><p><a href="https://nnethercote.github.io/perf-book/">The Rust performance Book</a></p>

<li><p><a href="https://likebike.com/posts/How_To_Write_Fast_Rust_Code.html">How to write Fast Rust code</a></p>

<li><p><a href="http://troubles.md/posts/rustfest-2018-workshop/">Fastware Workshope</a></p>

</ol>
<div class=page-foot >
  <div class=copyright >
    &copy; Miguel Raz Guzm√°n Macedo. Last modified: June 04, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>
    
    
        


	

<script>
(function(){

	// Get the elements.
	// - the 'pre' element.
	// - the 'div' with the 'paste-content' id.

	var pre = document.getElementsByTagName('pre');

	// Add a copy button in the 'pre' element.
	// which only has the className of 'language-'.

	for (var i = 0; i < pre.length; i++) {
		var isLanguage = pre[i].children[0].className.indexOf('language-');

		if ( isLanguage === 0 ) {
			var button           = document.createElement('button');
					button.className = 'copy-button';
					button.textContent = 'Copy';

					pre[i].appendChild(button);
		}
	};

	// Run Clipboard

	var copyCode = new Clipboard('.copy-button', {
		target: function(trigger) {
			return trigger.previousElementSibling;
    }
	});

	// On success:
	// - Change the "Copy" text to "Copied".
	// - Swap it to "Copy" in 2s.
	// - Lead user to the "contenteditable" area with Velocity scroll.

	copyCode.on('success', function(event) {
		event.clearSelection();
		event.trigger.textContent = 'Copied';
		window.setTimeout(function() {
			event.trigger.textContent = 'Copy';
		}, 2000);

	});

	// On error (Safari):
	// - Change the  "Press Ctrl+C to copy"
	// - Swap it to "Copy" in 2s.

	copyCode.on('error', function(event) {
		event.trigger.textContent = 'Press "Ctrl + C" to copy';
		window.setTimeout(function() {
			event.trigger.textContent = 'Copy';
		}, 5000);
	});

})();
</script>