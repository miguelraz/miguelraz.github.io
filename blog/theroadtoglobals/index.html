<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <!--<link rel=stylesheet  href="/libs/highlight/github.min.css"> --> <link rel=stylesheet  href="/libs/highlight/styles/atom-one-dark.css"> <script src="libs/clipboard.min.js"></script> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/basic.css"> <link rel=icon  href="/assets/favicon.ico" type="image/x-icon"> <title>üöß WIP üöß The road to typed globals in Julia</title> <header> <div class=blog-name ><a href="">PathToPerformance</a></div> <nav> <ul> <li><a href="/">Welcome! üëãüèæ</a> <li><a href="/diary/">Diaryüìí</a> <li><a href="/blog/">Blogüí≠</a> <li><a href="/pubs/">Publications üìì /Talksüó£Ô∏è /Videosüé• </a> <li><a href="/teaching/">Teachingüéì/Translationsüó∫Ô∏è</a> <li><a href="/about/">CVüíÉ</a> <script src="/libs/clipboard.js"></script> </ul> <img src="/assets/hamburger.svg" id=menu-icon > </nav> </header> <div class=franklin-content ><p>Plan of attack:</p> <ul> <li><p>Add a type field to every global binding -&gt; Easier task, probably mechanical. Look for it in the C code that implements global bindings.</p> </ul> <ol> <li><p>At the behest of Stefan, he suggested the following:</p> </ol> <blockquote> <p>Figure out what happens when you do <code>x &#61; 123</code> in global scope, that should help</p> </blockquote> <h3 id=finding_what_happens_with_x_123 ><a href="#finding_what_happens_with_x_123" class=header-anchor >Finding what happens with <code>x &#61; 123</code></a></h3> <p>I tried <code>rg &quot;assignment&quot;</code> within <code>julia/src</code> and tried to clue where I could find the culprit. I posted in Slack aobut it, and Simeon Schaub pointed me towards <code>src/interpreter.c</code> &#40;which came up in one of the <code>rg</code> searches but I ignored it&#41;.</p> <p>&#40;Morning&#33;&#41; I finally landed on something interesting</p> <pre><code class="c hljs"><span class=hljs-keyword >else</span> <span class=hljs-keyword >if</span> (jl_is_expr(stmt)) {
    <span class=hljs-number >1</span>             <span class=hljs-comment >// Most exprs are allowed to end a BB by fall through</span>
    <span class=hljs-number >2</span>             <span class=hljs-type >jl_sym_t</span> *head = ((<span class=hljs-type >jl_expr_t</span>*)stmt)-&gt;head;
    <span class=hljs-number >3</span>             <span class=hljs-keyword >if</span> (head == jl_assign_sym) {
    <span class=hljs-number >4</span>                 <span class=hljs-type >jl_value_t</span> *lhs = jl_exprarg(stmt, <span class=hljs-number >0</span>);
    <span class=hljs-number >5</span>                 <span class=hljs-type >jl_value_t</span> *rhs = eval_value(jl_exprarg(stmt, <span class=hljs-number >1</span>), s);
    <span class=hljs-number >6</span>                 <span class=hljs-keyword >if</span> (jl_is_slot(lhs)) {
    <span class=hljs-number >7</span>                     <span class=hljs-type >ssize_t</span> n = jl_slot_number(lhs);
    <span class=hljs-number >8</span>                     assert(n &lt;= jl_source_nslots(s-&gt;src) &amp;&amp; n &gt; <span class=hljs-number >0</span>);
    <span class=hljs-number >9</span>                     s-&gt;locals[n - <span class=hljs-number >1</span>] = rhs;
   <span class=hljs-number >10</span>                 }
   <span class=hljs-number >11</span>                 <span class=hljs-keyword >else</span> {
   <span class=hljs-number >12</span>                     <span class=hljs-type >jl_module_t</span> *modu;
   <span class=hljs-number >13</span>                     <span class=hljs-type >jl_sym_t</span> *sym;
   <span class=hljs-number >14</span>                     <span class=hljs-keyword >if</span> (jl_is_globalref(lhs)) {
   <span class=hljs-number >15</span>                         modu = jl_globalref_mod(lhs);
   <span class=hljs-number >16</span>                         sym = jl_globalref_name(lhs);
   <span class=hljs-number >17</span>                     }
   <span class=hljs-number >18</span>                     <span class=hljs-keyword >else</span> {
   <span class=hljs-number >19</span>                         assert(jl_is_symbol(lhs));
   <span class=hljs-number >20</span>                         modu = s-&gt;module;
   <span class=hljs-number >21</span>                         sym = (<span class=hljs-type >jl_sym_t</span>*)lhs;
   <span class=hljs-number >22</span>                     }
   <span class=hljs-number >23</span>                     JL_GC_PUSH1(&amp;rhs);
   <span class=hljs-number >24</span>                     <span class=hljs-type >jl_binding_t</span> *b = jl_get_binding_wr(modu, sym, <span class=hljs-number >1</span>);
   <span class=hljs-number >25</span>                     jl_checked_assignment(b, rhs);
   <span class=hljs-number >26</span>                     JL_GC_POP();
   <span class=hljs-number >27</span>                 }
   <span class=hljs-number >28</span>             }</code></pre> <p>This is a block that checks if there is an expression, and if it is an assignment, to handle the assignment.</p> <p>Specifically, it&#39;s the block on lines 23-26 that assigns to globals, but first it must &#40;by fishing for the definition of <code>jl_get_binding_wr</code> and <code>jl_checked_assignment</code>&#41;</p> <ul> <li><p>check there is a binding</p> <li><p>check the types match and assign the value &#40;aka, actually carry out the <code>x &#61; 123</code>.&#41;</p> </ul> <p>Now thinking a bit more clearly in the morning, it is not sufficient to just patch the assigment here in the <code>src/interpreter.c</code>, because that would only help when the REPL is running, but also with the <code>jl_check_assigment</code> function itself.</p> <p>Let&#39;s read what&#39;s in <code>jl_checked_assignment</code>:</p> <pre><code class="julia hljs">JL_DLLEXPORT void jl_checked_assignment(jl_binding_t *b, jl_value_t *rhs) JL_NOTSAFEPOINT
    <span class=hljs-number >1</span> {
    <span class=hljs-number >2</span>     <span class=hljs-keyword >if</span> (b-&gt;constp) {
    <span class=hljs-number >3</span>         jl_value_t *old = NULL;
    <span class=hljs-number >4</span>         <span class=hljs-keyword >if</span> (jl_atomic_cmpswap(&amp;b-&gt;value, &amp;old, rhs)) {
    <span class=hljs-number >5</span>             jl_gc_wb_binding(b, rhs);
    <span class=hljs-number >6</span>             <span class=hljs-keyword >return</span>;
    <span class=hljs-number >7</span>         }
    <span class=hljs-number >8</span>         <span class=hljs-keyword >if</span> (jl_egal(rhs, old))
    <span class=hljs-number >9</span>             <span class=hljs-keyword >return</span>;
   <span class=hljs-number >10</span>         <span class=hljs-keyword >if</span> (jl_typeof(rhs) != jl_typeof(old) || jl_is_type(rhs) || jl_is_module(rhs)) {
   <span class=hljs-number >11</span> <span class=hljs-comment >#ifndef __clang_gcanalyzer__</span>
   <span class=hljs-number >12</span>             jl_errorf(<span class=hljs-string >&quot;invalid redefinition of constant %s&quot;</span>,
   <span class=hljs-number >13</span>                       jl_symbol_name(b-&gt;name));
   <span class=hljs-number >14</span> <span class=hljs-comment >#endif</span>
   <span class=hljs-number >15</span>         }
   <span class=hljs-number >16</span>         jl_safe_printf(<span class=hljs-string >&quot;WARNING: redefinition of constant %s. This may fail, cause incorrect answers, or produce other errors.\n&quot;</span>,
   <span class=hljs-number >17</span>                        jl_symbol_name(b-&gt;name));
   <span class=hljs-number >18</span>     }
   <span class=hljs-number >19</span>     jl_atomic_store_relaxed(&amp;b-&gt;value, rhs);
   <span class=hljs-number >20</span>     jl_gc_wb_binding(b, rhs);
   <span class=hljs-number >21</span> }</code></pre> <p>Ok let&#39;s see what&#39;s going on here:</p> <ol> <li><p>The input is a <code>jl_binding_t</code> or a Julia <code>b</code>inding type pointer, and a <code>jl_value_t *rhs</code> a pointer to the type of the right hand side.</p> </ol> <p>Hmmm - I don&#39;t know what this type is so I&#39;ll go grep around and see what that is. &#40;15 mins later&#41; Ok, the grepping was kinda hit and miss and I scrolled aimlessly for a bit until I saw the <code>static</code> so I think that meant a definition and I think I found what <code>jl_binding_t</code> is in <code>module.c</code>:</p> <pre><code class="julia hljs">static jl_binding_t *new_binding(jl_sym_t *name)
    <span class=hljs-number >1</span> {
    <span class=hljs-number >2</span>     jl_task_t *ct = jl_current_task;
    <span class=hljs-number >3</span>     assert(jl_is_symbol(name));
    <span class=hljs-number >4</span>     jl_binding_t *b = (jl_binding_t*)jl_gc_alloc_buf(ct-&gt;ptls, sizeof(jl_binding_t));
    <span class=hljs-number >5</span>     b-&gt;name = name;
    <span class=hljs-number >6</span>     b-&gt;value = NULL;
    <span class=hljs-number >7</span>     b-&gt;owner = NULL;
    <span class=hljs-number >8</span>     b-&gt;globalref = NULL;
    <span class=hljs-number >9</span>     b-&gt;constp = <span class=hljs-number >0</span>;
   <span class=hljs-number >10</span>     b-&gt;exportp = <span class=hljs-number >0</span>;
   <span class=hljs-number >11</span>     b-&gt;imported = <span class=hljs-number >0</span>;
   <span class=hljs-number >12</span>     b-&gt;deprecated = <span class=hljs-number >0</span>;
   <span class=hljs-number >13</span>     <span class=hljs-keyword >return</span> b;
   <span class=hljs-number >14</span> }</code></pre> <p>So this must be what a &quot;variable&quot; looks like to Julia&#33; We check that the <code>name</code> can be made into a symbol, allocate storage for a <code>jl_binding_t</code> through the <code>*b</code> pointer , and then proceed to state it&#39;s value, and all the interesting internal knobs to work with it</p> <p>In a humbling moment, I realize that this definition is literally atop of the previous one I just read. Literally 2 lines of code above.</p> <p>Wiping away a single tear, let&#39;s consider if we shold add a global type to this struct itself.</p> <ol start=2 > <li><p>Now all those <code>b-&gt;things</code> make a lot more sense in the <code>jl_checked_assignment</code>:</p> </ol> <p>You check if different properties apply by going through the pointer and do the appropriate way of assigning.</p> <ol start=3 > <li><p>&#40;15 minutes later&#41; Hmm - I think this is still building a <code>jl_binding_t</code>, not specifically defining the struct for it. If I want to modify that struct itself I need to find the actual definition, because I&#39;m actually looking at the the function <code>new_binding&#40;jl_sym_t *name&#41;&#123;...&#125;</code>, which is a function that is given the pointer to a symbol and constructs a binding from it, not the structure of the binding itself.</p> <li><p>Ok, the file I was looking at <code>src/module.c</code> where <code>jl_checked_assignment</code> is defined only imports <code>&quot;julia.h&quot;</code> and like 2 other files, so it stands to reason that the struct is defined from a place it&#39;s imported. Fire up the editor and I get:</p> </ol> <pre><code class="julia hljs">typedef <span class=hljs-keyword >struct</span> {
     <span class=hljs-number >1</span>     // not first-class
     <span class=hljs-number >2</span>     jl_sym_t *name;
     <span class=hljs-number >3</span>     _Atomic(jl_value_t*) value;
     <span class=hljs-number >4</span>     _Atomic(jl_value_t*) globalref;  // cached <span class=hljs-built_in >GlobalRef</span> <span class=hljs-keyword >for</span> this binding
     <span class=hljs-number >5</span>     <span class=hljs-keyword >struct</span> _jl_module_t* owner;  // <span class=hljs-keyword >for</span> individual imported bindings -- TODO: make _Atomic
     <span class=hljs-number >6</span>     uint8_t constp:<span class=hljs-number >1</span>;
     <span class=hljs-number >7</span>     uint8_t exportp:<span class=hljs-number >1</span>;
     <span class=hljs-number >8</span>     uint8_t imported:<span class=hljs-number >1</span>;
     <span class=hljs-number >9</span>     uint8_t deprecated:<span class=hljs-number >2</span>; // <span class=hljs-number >0</span>=not deprecated, <span class=hljs-number >1</span>=renamed, <span class=hljs-number >2</span>=moved to another package
    <span class=hljs-number >10</span> } jl_binding_t;</code></pre> <p>Which is a weird looking struct but it&#39;s the C way to make one, via a <code>typedef</code> and putting the name after the <code>struct &#123;...&#125; name</code>.</p> <ol start=5 > <li><p>&#40;10 minutes later&#41; OK so re-reading the assignment <a href="https://github.com/JuliaLang/julia/issues/8870#issuecomment-320101744">about global type annotations</a>, the point is to add a </p> </ol> <p>special path to the function and if if there is a <code>x::Int &#61; 123</code> typing, then make that type valid.</p> <ol start=6 > <li><p>&#40;post lunch slump&#41; Chat has answered: Jeff suggests we just add a <code>jl_value_t *ty</code> to the struct and get it on with. Actually started a new <code>typedglobals</code> git branch and started adding code.</p> <li><p>&#40;spaced out on twitter for 10 minutes&#41; Ok actually added code.</p> </ol> <div class=page-foot > <div class=copyright > &copy; Miguel Raz Guzm√°n Macedo. Last modified: April 14, 2022. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. <script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "efaaeb52e1314322a75ffd9edd8d1566"}'></script> </div> </div> </div> <script> (function(){ // Get the elements. // - the 'pre' element. // - the 'div' with the 'paste-content' id. var pre = document.getElementsByTagName('pre'); // Add a copy button in the 'pre' element. // which only has the className of 'language-'. for (var i = 0; i < pre.length; i++) { var isLanguage = pre[i].children[0].className.indexOf('language-'); if ( isLanguage === 0 ) { var button = document.createElement('button'); button.className = 'copy-button'; button.textContent = 'Copy'; pre[i].appendChild(button); } }; // Run Clipboard var copyCode = new Clipboard('.copy-button', { target: function(trigger) { return trigger.previousElementSibling; } }); // On success: // - Change the "Copy" text to "Copied". // - Swap it to "Copy" in 2s. // - Lead user to the "contenteditable" area with Velocity scroll. copyCode.on('success', function(event) { event.clearSelection(); event.trigger.textContent = 'Copied'; window.setTimeout(function() { event.trigger.textContent = 'Copy'; }, 2000); }); // On error (Safari): // - Change the "Press Ctrl+C to copy" // - Swap it to "Copy" in 2s. copyCode.on('error', function(event) { event.trigger.textContent = 'Press "Ctrl + C" to copy'; window.setTimeout(function() { event.trigger.textContent = 'Copy'; }, 5000); }); })(); </script> <script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "efaaeb52e1314322a75ffd9edd8d1566"}'></script>