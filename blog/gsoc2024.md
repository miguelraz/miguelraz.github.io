@def title = "GSoC in LLVM 2024"
@def author = "Miguel Raz Guzmán Macedo"
@def tags = ["LLVM", "Julia", "LLVM"]
@def rss = "GSoC in LLVM 2024"
@def rss_pubdate = Date(2024, 02, 29)
@def published = "02 29 2024"
@def rss_guid = 9

# I'm trying to get a GSoC 2024 in LLVM

and I will be documenting my work with this ongoing blogpost in reverse chronological order.

---

If you want to see more posts like this, consider chucking a buck or two on my [GitHub sponsors](https://github.com/miguelraz), or, you know, hire me as a grad student.

---

## 10/02/2024 

Plan for today: Read the IR Verifier, add code to it if needed, then work on adding to SDAG node.

IR Verifier code: It's under `llvm/IR/Verifier.h` and `llvm/IR/Verifier.cpp`.

Ok, read the code for a bit. What I'm interested in in `Verifier.cpp` is the huge switch statement towards the end of the file where the verification of intrinsics happens.

Oh neat, learned a lot of places that probably need modification via searching `case Intrinsic::` in the llvm folder.

Neat! `VectorUtils.cpp` looks like where we add SIMD :D

There is also a `SelectionDAGBuilder.cpp` that seems like I should update stuff there.

Ah, seems the SDAG needs the ID node to be added to the ISDOpcodes first, like `ISD::SCMP` and such.

[Intrinsic Function](https://llvm.org/docs/LangRef.html#intrinsic-functions): start with `llvm.` prefix.
Must always be external functions. If any are added, must be documented in LangRef. Have naming convention on type name return.

In `TargetLowering.h`:
```
/// This class defines information used to lower LLVM code to legal SelectionDAG
/// operators that the target instruction selector can accept natively.
///
/// This class also defines callbacks that targets must implement to lower
/// target-specific constructs to SelectionDAG operators.
class TargetLowering : public TargetLoweringBase {
```

Updated the PR to not include a dirty file from the `ValueTracking.cpp` unit tests.

Sweet, rebased the `spaceship-intrinsic` branch changes into a new one.

Now I can go for 

```
lib/CodeGen/SelectionDAG/SelectionDAG.cpp:

Add code to print the node to getOperationName. If your new node can be
evaluated at compile time when given constant arguments (such as an add of a constant with another constant), find the getNode method that takes the appropriate number of arguments, and add a case for your node to the switch statement that performs constant folding for nodes that take the same number of arguments as your new node.
```

Which gives on Line 6629 of `SelectionDAG.cpp`

```
SDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, EVT VT,
                              SDValue N1, SDValue N2, const SDNodeFlags Flags) {
```

where I can add an `case ISD::UCMP`/`case ISD::SCMP`. 

Oh wow, having VSCode let me just hover over a type and give me info is amazing.

Alright, did some good work today I think.


## 09/02/2024

Lost the renaming battle to standard practices. Can't complain. Updated the PR to reflect that.

Now, reading the [DCE](https://github.com/llvm/llvm-project/blob/release/17.x/llvm/lib/Transforms/Scalar/DCE.cpp) pass code.

Ok, Andrzej Warzyński did [an incredibly useful tutorial](https://www.youtube.com/watch?v=ar7cJl2aBuU) for `llvm-tutor`.

I'll try writing the Transformation pass, since it's closes to what I need.

Notes:
    * `LLVM_DEBUG` is super useful. 
    ```
#include "llvm/ADT/Statistic.h"
#include "llvm/Support/Debug.h"

#define DEBUG_TYPE "mba-add"
STATISIC(SubstCount, "The # of substituted instructions"
    ```
    and then you can do:
    ```
    LLVM_DEBUG(dbgs() << *BinOp << " -> " << *NewInst << "\n";
    // or , with Statistic and `-stat` on the `opt` CLI and debug build
    ++SubstCount;
    ```

* Analysis inherits from `AnalysisInfoMixin`

* Very common pattern:
```
for (auto &Func : M) {
    for (auto &BB : Func) {
        for (auto &Ins : BB) {
            ...
```

* You call `PreservedAnalysis.abandon()` when you wanna bail on a logic.

* `FileCheck` is a pattern matching tool that comes with LLVM. Can check emitted assembly output for test correctness.

* Rely on CMake's `find_package` and add sanity-checks to your scripts!

* LLDB is your friend 
```
lldb -- $LLVM_DIR/bin/opt -load-pass-plugin lib/libMyPass.so -passes=my-pass -S dummy.ll
(lldb) b MyPass::run 
(lldb) r
```

Finally: started a branch called `scmp-and-ucmp` and I'll start trying out changes there whilst people make up their minds.



## 8/02/2024 

Jyn strikes again and sometimes you can just do `make` after `cmake` because some stuff is optional.

Otherwise, install:

```
sudo apt install libzstd-dev libcurl4-openssl-dev libedit-dev
```
to get rolling.

Once you do 
```
# Run the pass
$LLVM_DIR/bin/opt -load-pass-plugin ./libHelloWorld.{so|dylib} -passes=hello-world -disable-output input_for_hello.ll
# Expected output
(llvm-tutor) Hello from: foo
(llvm-tutor)   number of arguments: 1
(llvm-tutor) Hello from: bar
(llvm-tutor)   number of arguments: 2
(llvm-tutor) Hello from: fez
(llvm-tutor)   number of arguments: 3
(llvm-tutor) Hello from: main
(llvm-tutor)   number of arguments: 2
```
using `-disable-output` means no bitcode gets produced.

Passes come in 3 flavors, mostly: Analysis, Transformations and CFG manipulations.

Note that `clang` adds the `optnone` function attribute if 1) no opt level is specified or 
`-O0` is specified. 

Ah, forgot to run the `cmake .. -> mold -run make -j` and had some passes missing. Derp.

Minutes lost to cmake bullshit: 60.

Oh sweet! I just learned that I can write an injection pass that will give me a new binary and it will print out cool analysis info.

Also, if I get an instrumented binary I can just use `lli` to interpret the `.ll` file directly.

You can also build a static binary that will run that analysis for you! 

Ran a bunch of passes with `opt` and friends. Transformation passes will normally inherit from `PassInfoMixin`.

Analysis Passes will inherit from `AnalysisInfoMixin`.

Ok, cool I an outdated example in llvm-tutor [in the examples](https://github.com/banach-space/llvm-tutor/pull/111) and sent a PR for it.

Tomorrow I shall dive into those optimization passes at the end and hopefully run some good `lit` tests.


## 7/02/2024 

Alright, did some good catchup on the semester and pushed the [PR forward a bit](https://discourse.llvm.org/t/rfc-add-3-way-comparison-intrinsics/76685/7?u=miguelraz).

I also had an awesome "uniwtting tourist" genius moment by pointing out the return type could be different than what Nikita had thought of.

Today I setup my environment with

```
wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | sudo apt-key add -
sudo apt-add-repository "deb http://apt.llvm.org/jammy/ llvm-toolchain-jammy-17 main"
sudo apt-get update
sudo apt-get install -y llvm-17 llvm-17-dev llvm-17-tools clang-17
```

so now I can run `opt` shenanigans without awkward path invocations.

## 2/02/2024 

I'm waiting for others to chime in on my latest fix so I will be reading on how to add [unit tests](https://llvm.org/docs/TestingGuide.html).

Cool, that took like 25 minutes and I pushed a commit into the unit test generation framework.

Took me a bit but tried adding using `llvm-lit` and couldn't get the `Examples` folder to run,
so I posted a question in the #beginners channel about it.

## 1/02/2024 

Sweet! I was able to address Nikita's refactoring comments without too much hassle.

I guess the next task is to add it to the Verifier.

-> I read the `llvm/lib/IR/Verifier.cpp` header and grep'd for `smin`. Seems I can add a 

```
Intrinsics::vector_reduce_sthreecmp:
Intrinsics::vector_reduce_uthreecmp:
```

on line 5378 and get away with this. I don't see other places where it's defined.

I think I've hit my potential here. I will go do some tutorials.


## 29/02/2024 

### "hazlo cobarde"

Add the [3 way comparison instruction](https://discourse.llvm.org/t/llvm-add-3-way-comparison-intrinsics/76807/10) `<=>` to LLVM. 

I like this GSoC in particular because

* I will learn a wide swath of LLVM 
* I'll be working with a lot of optimization passes
* I'll get to bring cool perf to C++/Rust and Julia
* I was dared by [the other, more talented Miguel](https://twitter.com/DrawsMiguel/status/1759708211286835309) to actually help improve LLVM

### Task 1: Add to LangRef

[Add a new intrinsic](https://llvm.org/docs/ExtendingLLVM.html) - `Langref`, then `Intrinsics.td`, then maybe the pass verifier.

I've already put up a [sample PR](https://github.com/llvm/llvm-project/pull/83227) and got redirected on what looks like the proper working path for this endeavour.

Oh neat, I've finished. Only took about 1 hour with careful copy pasting. I'm probably blundering the return type being `iM` bits, but someone will correct me.

Now, I need to add an entry of the intrinsic into TableGen.

### Task 2: Add to Intrinsics.td

Whelp, I guess I gotta learn tablegen and then this `Intrinsics.td` file.

Ok, I found [a non-intimidating TableGen overview](https://llvm.org/docs/TableGen/index.html).

Gotta find the optimization wizardry in there after reading for a few minutes.

Alright, took more than a bit of an hour but [I got pushed something for this task](https://github.com/llvm/llvm-project/pull/83227#issuecomment-1972375003).

Pinged Nikita to get some adults to look at my horrible TableGen incantation.

See ya tomorrow.


